import qupath.lib.objects.PathObjects
import qupath.lib.roi.RoiTools
import java.awt.geom.Area

// ================== PARAMETRI ==================
def channelName = "Yellow"   // Canale da processare
def minArea = 10.0           // Area minima per fondere
def gridSize = 200.0         // Griglia spaziale per accelerare ricerca vicini

def allHexes = getDetectionObjects().findAll { it.getPathClass() == getPathClass(channelName) }
if (allHexes.isEmpty()) {
    print "Nessun esagono trovato per il canale ${channelName}!"
    return
}

print "Detections totali: ${allHexes.size()}"

// ================== CREA GRIGLIA SPAZIALE ==================
def grid = [:].withDefault { [] }
allHexes.each { obj ->
    def roi = obj.getROI()
    double cx = roi.getCentroidX()
    double cy = roi.getCentroidY()
    def key = [Math.floor(cx / gridSize), Math.floor(cy / gridSize)]
    grid[key] << obj
}

// ================== FUSIONE ==================
def toAdd = []
def toRemove = []

def smallHexes = allHexes.findAll { it.getROI().getGeometry().getArea() < minArea }

smallHexes.each { small ->
    def roiSmall = small.getROI()
    def cx = roiSmall.getCentroidX()
    def cy = roiSmall.getCentroidY()
    def gx = Math.floor(cx / gridSize)
    def gy = Math.floor(cy / gridSize)

    // Candidati vicini (celle adiacenti)
    def candidates = []
    for (dx in -1..1) {
        for (dy in -1..1) {
            def key = [gx + dx, gy + dy]
            candidates += grid[key]
        }
    }
    candidates = candidates.findAll { it != small && !toRemove.contains(it) }
    if (candidates.isEmpty()) return

    // Trova vicino contiguo: intersezione > 0 o bounding box vicina
    def nearest = candidates.min { c ->
        def area1 = new Area(roiSmall.getShape())
        def area2 = new Area(c.getROI().getShape())
        def intersection = new Area(area1)
        intersection.intersect(area2)
        if (!intersection.isEmpty()) return 0.0  // Se toccano, priorità massima
    
        // Bounding box
        def r1x = roiSmall.getBoundsX()
        def r1y = roiSmall.getBoundsY()
        def r1w = roiSmall.getBoundsWidth()
        def r1h = roiSmall.getBoundsHeight()
    
        def r2x = c.getROI().getBoundsX()
        def r2y = c.getROI().getBoundsY()
        def r2w = c.getROI().getBoundsWidth()
        def r2h = c.getROI().getBoundsHeight()
    
        double dx = Math.max(Math.max(r1x - (r2x + r2w), r2x - (r1x + r1w)), 0)
        double dy = Math.max(Math.max(r1y - (r2y + r2h), r2y - (r1y + r1h)), 0)
        Math.hypot(dx, dy)
    }

    if (nearest != null) {
        // FUSIONE
        def mergedArea = new Area(roiSmall.getShape())
        mergedArea.add(new Area(nearest.getROI().getShape()))
        def roi = RoiTools.getShapeROI(mergedArea, roiSmall.getImagePlane())
        def obj = PathObjects.createDetectionObject(roi, small.getPathClass())

        // Misurazioni aggiornate
        def m = obj.getMeasurementList()
        def geom = roi.getGeometry()
        m.put("Area µm²", geom.getArea())
        m.put("Perimeter µm", geom.getLength())
        m.put("BBox Width µm", roi.getBoundsWidth())
        m.put("BBox Height µm", roi.getBoundsHeight())
        m.put("Centroid X", roi.getCentroidX())
        m.put("Centroid Y", roi.getCentroidY())

        // Rimuovi originali e aggiungi nuovo
        toRemove << small
        toRemove << nearest
        toAdd << obj

        // Aggiorna griglia
        def newKey = [Math.floor(roi.getCentroidX() / gridSize), Math.floor(roi.getCentroidY() / gridSize)]
        grid[newKey] << obj
    }
}

// ================== AGGIORNA QUIPATH ==================
allHexes.removeAll(toRemove)
allHexes.addAll(toAdd)

removeObjects(getDetectionObjects().findAll { it.getPathClass() == getPathClass(channelName) }, true)
addObjects(allHexes)

print "Fusione completata. Numero esagoni finali: ${allHexes.size()}"
