//AUTHORS: Alessandro Ambrogiani, Filippo Piccinini
//CONTACTS: ambrogiani28@gmail.com, filippo.piccinini85@gmail.com
//DATE: 20251017
//NAME: HistologicalImagesFromOpticalToFlorecence
//DESCRIPTION: This ImageJ macro processes histological fluorescence images and allows manual cleaning of the GREEN channel (CD80) and the RED channel (CD163). 
// It enables the user to interactively select unwanted regions using the freehand tool, create a binary mask, and apply it through a Multiply operation 
// to remove selected areas from the channel. After modification, the script automatically rebuilds the RGB image from the individual red, green, 
// and blue channels, saves the composite image as a PNG file, and logs the performed operations. This workflow ensures controlled manual 
// preprocessing of fluorescence images for further quantitative analysis.
//COPYRIGHT: 
/*
 MiAI (Microscopy and Artificial Intelligence) Toolbox
 Copyright © 2025 Alessandro Ambrogiani, Filippo Piccinini.
 University of Bologna, Italy. All rights reserved.
 This program is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License version 3 (or higher)
 as published by the Free Software Foundation. This program is
 distributed WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
 */

//Define input file
run("Close All");
path1 = File.openDialog("Select a File");
dir1 = File.getParent(path1);
name1 = File.getName(path1);
print("Path:", path1);
print("Name:", name1);
print("Directory:", dir1);
dotIndex = lastIndexOf(name1, ".");
if (dotIndex != -1) {
    name1WithoutExtension = substring(name1, 0, dotIndex);
} else {
    name1WithoutExtension = name1; // No extension found
}

//Define output parameters
outputROIname1 = getString("Enter the name for the ROI analysed: ", "");
dir2 = getDirectory("Set the output directory (subfolders will be automatically created): ");
dir2Subfolder = dir2 + "/" + name1WithoutExtension + "_" + outputROIname1 + "/";
File.makeDirectory(dir2Subfolder); 

// Crea file di log
logFile = dir2Subfolder + name1WithoutExtension + outputROIname1 + "_processing_log.txt";

//Open input file
list = getFileList(dir1);
print("Directory contains "+list.length+" files");
open(path1);
// correzione: seleziono sempre l’ultima immagine aperta
selectImage(nImages);
bitDepth1 = bitDepth();
print(bitDepth1);

if(bitDepth1 == 24){
    print("Image is RGB.");
} else {
    print("Image is not RGB.");
    run("Stack to RGB");
    selectImage(nImages);
    close();
    selectImage(nImages);
    rename(name1);
}

if (bitDepth1 != 24) {
    run("RGB Color");
}

// Save ColourDeconvolution images
run("Colour Deconvolution", "vectors=[FastRed FastBlue DAB]");

selectImage(name1+" (RGB)-(Colour_1)");
outputCH1name1 = getString("Enter the name for the 1st channel: ", "CD163");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN-1.tif");

selectImage(name1+" (RGB)-(Colour_2)");
outputCH2name1 = getString("Enter the name for the 2nd channel: ", "NUCLEI");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN-1.tif");

selectImage(name1+" (RGB)-(Colour_3)");
outputCH3name1 = getString("Enter the name for the 3rd channel: ", "CD8");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN-1.tif");

run("Close All");

// === FUNCTION: PROCESS SINGLE CHANNEL ===
// Performs thresholding, optional median filtering, and manual editing
function processChannel(channelName, shortName, defaultAlgo, defaultRadius, applyDefaultIfNo) {
    open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_BN-1.tif");

    Dialog.create("Threshold & Median");
    Dialog.addMessage("Choose threshold algorithm for " + shortName);
    Dialog.addChoice("Algorithm:", 
        newArray("Default", "Huang", "Otsu", "Minimum", "Triangle", "Mean", "Moments", "Percentile", "Yen", "Intermodes"), 
        defaultAlgo);
    Dialog.show();
    algo = Dialog.getChoice();

    setAutoThreshold(algo + " dark no-reset");
    setOption("BlackBackground", true);

    selectionMedian = getString("Enter YES to apply median filter for " + shortName, "NO");
    if (selectionMedian == "YES") {
        radius = getNumber("Enter radius for median filter", defaultRadius);
        run("Median...", "radius=" + radius);
    } else {
        if (applyDefaultIfNo) {
            // solo CH1 applica comunque il filtro col raggio di default
            radius = defaultRadius;
            run("Median...", "radius=" + radius);
        } else {
            radius = 0; // nessun filtro applicato
        }
    }
 	// Convert to binary mask and save
    run("Convert to Mask");
    saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_TH.tif");
    
	// Optional manual processing of mask
    selectionManual = getString("Enter YES to reload and manually process the " + shortName + " binary mask:", "NO");
    if (selectionManual == "YES") {
        run("Close All");
        print("Manual process the " + shortName + " mask and save it as _TH.");
        open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_BN-1.tif");
        waitForUser("Manually process \nthe <_BN-1.tif> mask, \nmanually save it as <_TH.tif>, \nthen click OK.");
        print("Mask processed for " + shortName + ".");
        run("Close All");
    }

    result = newArray(algo, selectionMedian, radius);
    return result;
}

// === Process CH1 ===
resCH1 = processChannel(outputCH1name1, "CH1 (" + outputCH1name1 + ")", "Default", 10, true);
algoCH1 = resCH1[0];
medianAppliedCH1 = resCH1[1];
medianRadiusCH1 = resCH1[2];

// === Process CH2 ===
resCH2 = processChannel(outputCH2name1, "CH2 (" + outputCH2name1 + ")", "Moments", 12, false);
algoCH2 = resCH2[0];
medianAppliedCH2 = resCH2[1];
medianRadiusCH2 = resCH2[2];

// === Process CH3 ===
resCH3 = processChannel(outputCH3name1, "CH3 (" + outputCH3name1 + ")", "Yen", 12, false);
algoCH3 = resCH3[0];
medianAppliedCH3 = resCH3[1];
medianRadiusCH3 = resCH3[2];

print("All the binary masks are processed.");

// === NORMALIZE AND SAVE THRESHOLDED MASKS ===
// Divides pixel values by 255 to normalize binary masks (0–1)

run("Close All");

open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
run("Close All");
	
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
run("Close All");
	
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
run("Close All");

 // Overlap the binary masks

// CH1 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif");
run("Close All");

// CH2 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif");
run("Close All");

// CH3 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif");
run("Close All");

// Merge channels
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif");

Dialog.create("Choose color scheme for merged channels");
Dialog.addMessage("CH1 = " + outputCH1name1 + 
                  "\nCH2 = " + outputCH2name1 + 
                  "\nCH3 = " + outputCH3name1);
Dialog.addMessage("Select a color scheme:\n" +
                  "A: CH1=green, CH2=blue, CH3=red\n" +
                  "B: CH1=gray, CH2=blue, CH3=yellow\n" +
                  "C: CH1=magenta, CH2=blue, CH3=cyan\n" +
                  "D: CH1=cyan, CH2=blue, CH3=magenta\n" +
                  "E: CH1=red, CH2=blue, CH3=green\n" +
                  "F: CH1=magenta, CH2=blue, CH3=yellow\n" +
                  "G: CH1=yellow, CH2=blue, CH3=magenta");
Dialog.addChoice("Scheme:", newArray("A","B","C","D","E","F","G"), "E");
Dialog.show();
selectionString2 = Dialog.getChoice();
if(selectionString2 == "A"){
	print("A for CH1=green CH2=blue CH3=red.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
} else if (selectionString2 == "B"){
	print("B for CH1=gray CH2=blue CH3=yellow.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c4=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "C"){
	print("C for CH1=magenta CH2=blue CH3=cyan.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c5=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] create");
} else if (selectionString2 == "D"){
	print("D for CH1=cyan CH2=blue CH3=magenta.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c5=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "E"){
	print("E for CH1=red CH2=blue CH3= green.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
} else if (selectionString2 == "F"){
	print("F for CH1=magenta CH2=blue CH3=yellow.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "G"){
	print("G for CH1=yellow CH2=blue CH3=magenta.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] create");
} else {
	print("Wrong input: execute A. A for CH1=green CH2=blue CH3=red.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
}
run("Stack to RGB");

// === Function for manual cleaning of a single color channel ===
function manualChannelCleaning(channelColor, channelLabel) {
    selectionManual = getString("Enter YES to manually remove areas from the " + channelColor + " channel (" + channelLabel + ")", "NO");
    if (selectionManual != "YES") return "NO"; 

    print("Draw all regions you want to remove from the " + channelColor + " channel.");
    print("Tip: Hold SHIFT while drawing to add multiple regions to the same selection.");

    // Split channels only if image is RGB
    bitDepth1 = bitDepth();
    if (bitDepth1 == 24) {
        run("Split Channels");
    }

    // Identify correct channel
    titles = getList("image.titles");
    channelTitle = "";
    for (i = 0; i < titles.length; i++) {
        if (endsWith(titles[i], "(" + channelColor + ")")) {
            channelTitle = titles[i];
        }
    }

    if (channelTitle == "") {
        exit("Error: " + channelColor + " channel not found!");
    }

    selectImage(channelTitle);
    setTool("freehand");

    // Let user draw multiple freehand regions using SHIFT
    waitForUser("Draw all areas to remove on the " + channelColor + " channel.\nHold SHIFT to add multiple regions.\nClick OK when finished.");

    // Create mask from final multi-region selection
    run("Create Mask");
    rename("ManualMask_" + channelColor);
    run("Invert");
    run("Divide...", "value=255.000");

    // Apply the mask (remove selected regions)
    imageCalculator("Multiply create", channelTitle, "ManualMask_" + channelColor);
    selectImage("Result of " + channelTitle);
    rename(channelColor + "_Updated");

    // Cleanup
    close(channelTitle);
    close("ManualMask_" + channelColor);

    print("Manual multi-region mask applied to the " + channelColor + " channel.");

    return "YES";
}


// === MANUAL CLEANING ON GREEN (CD8) AND RED (CD163) CHANNELS ===
manualAppliedGreen = manualChannelCleaning("green", "CD8");
manualAppliedRed  = manualChannelCleaning("red", "CD163");



bitDepth1 = bitDepth();
if (bitDepth1 == 24) {
	run("Split Channels");
}

// === Rebuild final RGB image ===
titles = getList("image.titles");

// Initialize variables
redUpdated = "";
greenUpdated = "";
blueTitle = "";

// Identify default channel titles
for (i = 0; i < titles.length; i++) {
    if (endsWith(titles[i], "(red)"))   redUpdated = titles[i];
    if (endsWith(titles[i], "(green)")) greenUpdated = titles[i];
    if (endsWith(titles[i], "(blue)"))  blueTitle = titles[i];
}

// If manual cleaning was applied, use the updated versions instead
if (manualAppliedRed == "YES")   redUpdated = "red_Updated";
if (manualAppliedGreen == "YES") greenUpdated = "green_Updated";

// Merge final RGB image
run("Merge Channels...", "c1=[" + redUpdated + "] c2=[" + greenUpdated + "] c3=[" + blueTitle + "] create");
run("Stack to RGB");

close(redUpdated);
close(greenUpdated);
close(blueTitle);

// === FINAL DIALOG AND SAVE COMPOSITE IMAGE ===
Dialog.create("Processing!");
Dialog.addMessage("Please, click here OK but then wait 2 minutes for automatic saving and closing of the currently visualised images!");
Dialog.show();
saveAs("PNG", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_Composite.png");

// === LOG CREATION ===
logText = "";

logText += "Image: " + name1 + "\n\n";
logText += "ROI Name: " + outputROIname1 + "\n\n";
logText += "Output Directory: " + dir2Subfolder + "\n\n";

logText += "CH1 (" + outputCH1name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH1 + "\n";
logText += "  Median filter applied: " + medianAppliedCH1 + "\n";
logText += "  Median radius: " + medianRadiusCH1 + "\n\n";
logText += "Manual cleaning (freehand mask) applied to RED channel (CD163): " + manualAppliedRed + "\n\n";
logText += "\n";

logText += "CH2 (" + outputCH2name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH2 + "\n";
logText += "  Median filter applied: " + medianAppliedCH2 + "\n";
if (medianAppliedCH2 == "YES") logText += "  Median radius: " + medianRadiusCH2 + "\n";
logText += "\n";

logText += "CH3 (" + outputCH3name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH3 + "\n";
logText += "  Median filter applied: " + medianAppliedCH3 + "\n";
if (medianAppliedCH3 == "YES") logText += "  Median radius: " + medianRadiusCH3 + "\n\n";
logText += "Manual cleaning (freehand mask) applied to GREEN channel (CD8): " + manualAppliedGreen + "\n\n";

File.saveString(logText, logFile);
print("Processing log saved at: " + logFile);
print("Now you can close!");
run("Close All");
