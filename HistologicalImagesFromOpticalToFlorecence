//AUTHORS: Alessandro Ambrogiani, Filippo Piccinini
//CONTACTS: ambrogiani28@gmail.com, filippo.piccinini85@gmail.com
//DATE: 20251017
//NAME: HistologicalImagesFromOpticalToFlorecence
//DESCRIPTION: This ImageJ macro processes histological fluorescence images and allows manual cleaning of the GREEN channel (CD80) and the RED channel (CD163). 
// It enables the user to interactively select unwanted regions using the freehand tool, create a binary mask, and apply it through a Multiply operation 
// to remove selected areas from the channel. After modification, the script automatically rebuilds the RGB image from the individual red, green, 
// and blue channels, saves the composite image as a PNG file, and logs the performed operations. This workflow ensures controlled manual 
// preprocessing of fluorescence images for further quantitative analysis.
//COPYRIGHT: 
/*
 MiAI (Microscopy and Artificial Intelligence) Toolbox
 Copyright © 2025 Alessandro Ambrogiani, Filippo Piccinini.
 University of Bologna, Italy. All rights reserved.
 This program is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License version 3 (or higher)
 as published by the Free Software Foundation. This program is
 distributed WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
 */

//Define input file
run("Close All");
path1 = File.openDialog("Select a File");
dir1 = File.getParent(path1);
name1 = File.getName(path1);
print("Path:", path1);
print("Name:", name1);
print("Directory:", dir1);
dotIndex = lastIndexOf(name1, ".");
if (dotIndex != -1) {
    name1WithoutExtension = substring(name1, 0, dotIndex);
} else {
    name1WithoutExtension = name1; // No extension found
}

//Define output parameters
outputROIname1 = getString("Enter the name for the ROI analysed: ", "");
dir2 = getDirectory("Set the output directory (subfolders will be automatically created): ");
dir2Subfolder = dir2 + "/" + name1WithoutExtension + "_" + outputROIname1 + "/";
File.makeDirectory(dir2Subfolder); 

// Crea file di log
logFile = dir2Subfolder + name1WithoutExtension + outputROIname1 + "_processing_log.txt";

//Open input file
list = getFileList(dir1);
print("Directory contains "+list.length+" files");
open(path1);
// correzione: seleziono sempre l’ultima immagine aperta
selectImage(nImages);
bitDepth1 = bitDepth();
print(bitDepth1);

if(bitDepth1 == 24){
    print("Image is RGB.");
} else {
    print("Image is not RGB.");
    run("Stack to RGB");
    selectImage(nImages);
    close();
    selectImage(nImages);
    rename(name1);
}

if (bitDepth1 != 24) {
    run("RGB Color");
}

// Save ColourDeconvolution images
run("Colour Deconvolution", "vectors=[FastRed FastBlue DAB]");

selectImage(name1+" (RGB)-(Colour_1)");
Dialog.create("");
Dialog.addMessage("Select name for CH1");
Dialog.addChoice("name", newArray("CD163", "CD3"), "CD163");
Dialog.show();
outputCH1name1 = Dialog.getChoice();
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN-1.tif");

selectImage(name1+" (RGB)-(Colour_2)");
Dialog.create("");
Dialog.addMessage("Select name for CH2");
Dialog.addChoice("name", newArray("NUCLEI"), "NUCLEI");
Dialog.show();
outputCH2name1 = Dialog.getChoice();
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN-1.tif");

selectImage(name1+" (RGB)-(Colour_3)");
Dialog.create("");
Dialog.addMessage("Select name for CH3");
Dialog.addChoice("name", newArray("CD8", "CD20"), "CD8");
Dialog.show();
outputCH3name1 = Dialog.getChoice();
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + ".tif");
run("8-bit");
run("Invert");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif");
run("Duplicate...", " ");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN-1.tif");

run("Close All");

// === FUNCTION: PROCESS SINGLE CHANNEL ===
// Performs thresholding, optional median filtering, and manual editing
function processChannel(channelName, shortName, defaultAlgo, defaultRadius, applyDefaultIfNo) {
    open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_BN-1.tif");

    Dialog.create("Threshold & Median");
    Dialog.addMessage("Choose threshold algorithm for " + shortName);
    Dialog.addChoice("Algorithm:", 
        newArray("Default", "Huang", "Otsu", "Minimum", "Triangle", "Mean", "Moments", "Percentile", "Yen", "Intermodes"), 
        defaultAlgo);
    Dialog.show();
    algo = Dialog.getChoice();

    setAutoThreshold(algo + " dark no-reset");
    setOption("BlackBackground", true);

    selectionMedian = getString("Enter YES to apply median filter for " + shortName, "NO");
    if (selectionMedian == "YES") {
        radius = getNumber("Enter radius for median filter", defaultRadius);
        run("Median...", "radius=" + radius);
    } else {
        if (applyDefaultIfNo) {
            // solo CH1 applica comunque il filtro col raggio di default
            radius = defaultRadius;
            run("Median...", "radius=" + radius);
        } else {
            radius = 0; // nessun filtro applicato
        }
    }
 	// Convert to binary mask and save
    run("Convert to Mask");
    saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_TH.tif");
    
	// Optional manual processing of mask
    selectionManual = getString("Enter YES to reload and manually process the " + shortName + " binary mask:", "NO");
    if (selectionManual == "YES") {
        run("Close All");
        print("Manual process the " + shortName + " mask and save it as _TH.");
        open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + channelName + "_BN-1.tif");
        waitForUser("Manually process \nthe <_BN-1.tif> mask, \nmanually save it as <_TH.tif>, \nthen click OK.");
        print("Mask processed for " + shortName + ".");
        run("Close All");
    }

    result = newArray(algo, selectionMedian, radius);
    return result;
}

// === Process CH1 ===
resCH1 = processChannel(outputCH1name1, "CH1 (" + outputCH1name1 + ")", "Default", 10, true);
algoCH1 = resCH1[0];
medianAppliedCH1 = resCH1[1];
medianRadiusCH1 = resCH1[2];

// === Process CH2 ===
resCH2 = processChannel(outputCH2name1, "CH2 (" + outputCH2name1 + ")", "Moments", 12, false);
algoCH2 = resCH2[0];
medianAppliedCH2 = resCH2[1];
medianRadiusCH2 = resCH2[2];

// === Process CH3 ===
resCH3 = processChannel(outputCH3name1, "CH3 (" + outputCH3name1 + ")", "Yen", 12, false);
algoCH3 = resCH3[0];
medianAppliedCH3 = resCH3[1];
medianRadiusCH3 = resCH3[2];

print("All the binary masks are processed.");

// === NORMALIZE AND SAVE THRESHOLDED MASKS ===
// Divides pixel values by 255 to normalize binary masks (0–1)

run("Close All");

open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
run("Close All");
	
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
run("Close All");
	
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
run("Divide...", "value=255.000");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
run("Close All");

 // Overlap the binary masks

// CH1 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif");
run("Close All");

// CH2 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif");
run("Close All");

// CH3 part
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
imageCalculator("Multiply create", name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_BN.tif", name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_TH.tif");
saveAs("Tiff", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif");
run("Close All");

// Merge channels
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif");
open(dir2Subfolder + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif");

Dialog.create("Choose color scheme for merged channels");
Dialog.addMessage("CH1 = " + outputCH1name1 + 
                  "\nCH2 = " + outputCH2name1 + 
                  "\nCH3 = " + outputCH3name1);
Dialog.addMessage("Select a color scheme:\n" +
                  "A: CH1=green, CH2=blue, CH3=red\n" +
                  "B: CH1=gray, CH2=blue, CH3=yellow\n" +
                  "C: CH1=magenta, CH2=blue, CH3=cyan\n" +
                  "D: CH1=cyan, CH2=blue, CH3=magenta\n" +
                  "E: CH1=red, CH2=blue, CH3=green\n" +
                  "F: CH1=magenta, CH2=blue, CH3=yellow\n" +
                  "G: CH1=yellow, CH2=blue, CH3=magenta");
Dialog.addChoice("Scheme:", newArray("A","B","C","D","E","F","G"), "E");
Dialog.show();
selectionString2 = Dialog.getChoice();
if(selectionString2 == "A"){
	print("A for CH1=green CH2=blue CH3=red.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
} else if (selectionString2 == "B"){
	print("B for CH1=gray CH2=blue CH3=yellow.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c4=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "C"){
	print("C for CH1=magenta CH2=blue CH3=cyan.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c5=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] create");
} else if (selectionString2 == "D"){
	print("D for CH1=cyan CH2=blue CH3=magenta.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c5=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "E"){
	print("E for CH1=red CH2=blue CH3= green.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
} else if (selectionString2 == "F"){
	print("F for CH1=magenta CH2=blue CH3=yellow.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] create");
} else if (selectionString2 == "G"){
	print("G for CH1=yellow CH2=blue CH3=magenta.");
	run("Merge Channels...", "c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] c6=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c7=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] create");
} else {
	print("Wrong input: execute A. A for CH1=green CH2=blue CH3=red.");
	run("Merge Channels...", "c1=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH3name1 + "_DEF.tif] c2=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH1name1 + "_DEF.tif] c3=[" + name1WithoutExtension + outputROIname1 + "_" + outputCH2name1 + "_DEF.tif] create");
}
run("Stack to RGB");
rename("Composite_to_Clean");

// === Function for manual cleaning (MODIFIED) ===
// This function ONLY creates a mask from the user's drawing on the active color image.
// It does NOT apply the mask or split the channels.
function manualChannelCleaning(channelColor, channelLabel) {
    selectionManual = getString("Enter YES to manually remove areas from the " + channelColor + " channel (" + channelLabel + ")", "NO");
    if (selectionManual != "YES") return "NO"; 

    print("Draw all regions you want to remove from the " + channelColor + " channel.");
    print("Tip: Hold SHIFT while drawing to add multiple regions to the same selection.");

    selectImage(getTitle());
    setTool("freehand");

    waitForUser("Draw all areas to remove on the COLOR image for " + channelLabel + ".\nHold SHIFT to add multiple regions.\nClick OK when finished.");

    
    if (selectionType() == -1) { // -1 significa "nessuna selezione"
        print("No selection made. Skipping manual cleaning for " + channelColor + ".");
        return "NO"; // Ritorna "NO" come se l'utente avesse annullato
    }

    // Create mask
    run("Create Mask");
    rename("ManualMask_" + channelColor);
    print("Mask created for al " + channelColor);
    
    run("Select None"); 

    return "YES"; 
}


// === MANUAL CLEANING ON GREEN (CD8) AND RED (CD163) CHANNELS ===
manualAppliedRed  = manualChannelCleaning("red", outputCH1name1);
manualAppliedGreen = manualChannelCleaning("green", outputCH3name1);



// === Split the composite image ONCE (dopo aver disegnato) ===


selectImage("Composite_to_Clean"); 

bitDepth1 = bitDepth();
if (bitDepth1 == 24) {
	run("Split Channels"); 
}

// === Rebuild final RGB image ===
titles = getList("image.titles");

// Inizializza le variabili
redUpdated = "";
greenUpdated = "";
blueTitle = "";

// Identifica i titoli dei canali B/N appena divisi
for (i = 0; i < titles.length; i++) {
    if (endsWith(titles[i], "(red)"))   redUpdated = titles[i];
    if (endsWith(titles[i], "(green)")) greenUpdated = titles[i];
    if (endsWith(titles[i], "(blue)"))  blueTitle = titles[i];
}

// === Applica le maschere se sono state create ===

if (manualAppliedRed == "YES") {
    print("Applying manual mask to CH1 channel...");
    // Prepara la maschera
    selectImage("ManualMask_red");
    run("Invert");
    run("Divide...", "value=255.000");
    // Applica la maschera al canale B/N
    imageCalculator("Multiply create", redUpdated, "ManualMask_red");
    close(redUpdated); // Chiude il canale rosso originale (sporco)
    close("ManualMask_red");
    selectImage("Result of " + redUpdated);
    rename("red_Updated"); // Rinomina il risultato
    redUpdated = "red_Updated"; // Aggiorna la variabile per il merge finale
}

if (manualAppliedGreen == "YES") {
    print("Applying manual mask to CH3 channel...");
    // Prepara la maschera
    selectImage("ManualMask_green");
    run("Invert");
    run("Divide...", "value=255.000");
    // Applica la maschera al canale B/N
    imageCalculator("Multiply create", greenUpdated, "ManualMask_green");
    close(greenUpdated); // Chiude il canale verde originale (sporco)
    close("ManualMask_green");
    selectImage("Result of " + greenUpdated);
    rename("green_Updated"); // Rinomina il risultato
    greenUpdated = "green_Updated"; // Aggiorna la variabile per il merge finale
}

// Merge final RGB image
run("Merge Channels...", "c1=[" + redUpdated + "] c2=[" + greenUpdated + "] c3=[" + blueTitle + "] create");
run("Stack to RGB");

// Pulisci i canali B/N finali
close(redUpdated);
close(greenUpdated);
close(blueTitle);

// === FINAL DIALOG AND SAVE COMPOSITE IMAGE ===
Dialog.create("Processing!");
Dialog.addMessage("Please, click here OK but then wait 2 minutes for automatic saving and closing of the currently visualised images!");
Dialog.show();
saveAs("PNG", dir2Subfolder + name1WithoutExtension + outputROIname1 + "_Composite.png");

// === LOG CREATION ===
logText = "";

logText += "Image: " + name1 + "\n\n";
logText += "ROI Name: " + outputROIname1 + "\n\n";
logText += "Output Directory: " + dir2Subfolder + "\n\n";

logText += "CH1 (" + outputCH1name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH1 + "\n";
logText += "  Median filter applied: " + medianAppliedCH1 + "\n";
logText += "  Median radius: " + medianRadiusCH1 + "\n\n";
logText += "Manual cleaning (freehand mask) applied to CH1 channel: " + manualAppliedRed + "\n\n";
logText += "\n";

logText += "CH2 (" + outputCH2name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH2 + "\n";
logText += "  Median filter applied: " + medianAppliedCH2 + "\n";
if (medianAppliedCH2 == "YES") logText += "  Median radius: " + medianRadiusCH2 + "\n";
logText += "\n";

logText += "CH3 (" + outputCH3name1 + "):\n";
logText += "  Threshold algorithm: " + algoCH3 + "\n";
logText += "  Median filter applied: " + medianAppliedCH3 + "\n";
if (medianAppliedCH3 == "YES") logText += "  Median radius: " + medianRadiusCH3 + "\n\n";
logText += "Manual cleaning (freehand mask) applied to CH2 channel: " + manualAppliedGreen + "\n\n";

File.saveString(logText, logFile);
print("Processing log saved at: " + logFile);
print("Now you can close!");
run("Close All");
