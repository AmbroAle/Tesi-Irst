import qupath.lib.objects.PathObjects
import qupath.lib.roi.*
import qupath.lib.roi.RoiTools
import qupath.lib.regions.ImagePlane
import java.awt.geom.Area

// ================== PARAMETRI ==================
def channelName = "Yellow"
def diametro = 15             // Diametro cerchi / esagoni
def raggio = diametro / 2.0
def cellSize = diametro / 2   // Celle per assegnazione residuo
def margin = diametro
def maxDist = 999999

def imageData = getCurrentImageData()
def hierarchy = imageData.getHierarchy()
def plane = ImagePlane.getDefaultPlane()

// Recupera tutti i blob
def blobs = getDetectionObjects().findAll { it.getPathClass() == getPathClass(channelName) }
if (blobs.isEmpty()) {
    print "Nessun blob trovato per il canale ${channelName}."
    return
}

blobs.each { blob ->

    def blobROI = blob.getROI()
    if (!blobROI) return
    def blobClass = blob.getPathClass()

    def xMin = blobROI.getBoundsX()
    def yMin = blobROI.getBoundsY()
    def w = blobROI.getBoundsWidth()
    def h = blobROI.getBoundsHeight()

    // ================== 1) CREA CERCHI ESAGONALI ==================
    def cerchi = []

    // calcola altezza esagono
    double hexHeight = Math.sqrt(3) * raggio

    int nRows = Math.ceil(h / hexHeight) as int
    int nCols = Math.ceil(w / diametro) as int

    for (int r = 0; r < nRows; r++) {
        for (int c = 0; c < nCols; c++) {

            double cx = xMin + c * diametro + raggio
            double cy = yMin + r * hexHeight + hexHeight/2

            // sfalsa le righe pari
            if (r % 2 == 1) cx += diametro / 2

            if (!blobROI.contains(cx, cy)) continue

            cerchi << ROIs.createEllipseROI(cx - raggio, cy - raggio, diametro, diametro)
        }
    }
    if (cerchi.isEmpty()) return

    // ================== 2) CALCOLA IL RESIDUO ==================
    def residuo = blobROI
    cerchi.each { c -> residuo = RoiTools.subtract(residuo, c) }
    if (!residuo) return

    def boundsX = residuo.getBoundsX()
    def boundsY = residuo.getBoundsY()
    def boundsW = residuo.getBoundsWidth()
    def boundsH = residuo.getBoundsHeight()

    // ================== 3) PREPARA CELLE PER ASSEGNAZIONE ==================
    def cerchiBounds = [:]
    cerchi.each { c ->
        def r = c.getBoundsWidth()/2
        def cx = c.getCentroidX()
        def cy = c.getCentroidY()
        cerchiBounds[c] = [
            minX: cx - r - margin,
            maxX: cx + r + margin,
            minY: cy - r - margin,
            maxY: cy + r + margin
        ]
    }

    def cellePerCerchio = [:]
    cerchi.each { cellePerCerchio[it] = new Area() }

    for (double y = boundsY; y < boundsY + boundsH; y += cellSize) {
        for (double x = boundsX; x < boundsX + boundsW; x += cellSize) {

            def cellROI = ROIs.createRectangleROI(x, y, cellSize, cellSize)
            def cellArea = new Area(cellROI.getShape())
            cellArea.intersect(new Area(residuo.getShape()))
            if (cellArea.isEmpty()) continue

            def cellCx = x + cellSize/2
            def cellCy = y + cellSize/2

            def candidati = cerchi.findAll { c ->
                def b = cerchiBounds[c]
                (cellCx >= b.minX && cellCx <= b.maxX && cellCy >= b.minY && cellCy <= b.maxY)
            }
            if (candidati.isEmpty()) candidati = cerchi

            double bestDist = maxDist
            def best = null
            candidati.each { c ->
                def dx = c.getCentroidX() - cellCx
                def dy = c.getCentroidY() - cellCy
                def dist = dx*dx + dy*dy
                if (dist < bestDist) {
                    bestDist = dist
                    best = c
                }
            }

            cellePerCerchio[best].add(cellArea)
        }
    }

    // ================== 4) CREA LE DETECTIONS FINALI ==================
    def finalObjects = cerchi.collect { c ->
        def area = new Area(c.getShape())
        area.add(cellePerCerchio[c])
        area.intersect(new Area(blobROI.getShape()))
        def finalROI = RoiTools.getShapeROI(area, plane)
        PathObjects.createDetectionObject(finalROI, blobClass)
    }

    hierarchy.removeObject(blob, true)
    hierarchy.addObjects(finalObjects)

    print "Blob processato â†’ ${finalObjects.size()} shapes finali."
}

// ================== 5) AGGIUNGI LE MISURAZIONI ==================
addShapeMeasurements(
    "AREA",
    "LENGTH",
    "CIRCULARITY",
    "SOLIDITY",
    "MAX_DIAMETER",
    "MIN_DIAMETER"
)

print "Processo completato! Misurazioni aggiunte."
